<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rubric</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><a href="setup.html">Setup</a></li><li class="chapter-item expanded "><a href="rubric/home.html"><strong aria-hidden="true">1.</strong> Rubrics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rubric/spec.html"><strong aria-hidden="true">1.1.</strong> Rubric Specification</a></li><li class="chapter-item expanded "><a href="rubric/tests.html"><strong aria-hidden="true">1.2.</strong> Criteria Tests</a></li></ol></li><li class="chapter-item expanded "><a href="submission/home.html"><strong aria-hidden="true">2.</strong> Submission</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="submission/prompt.html"><strong aria-hidden="true">2.1.</strong> Prompting for Data</a></li></ol></li><li class="chapter-item expanded "><a href="dropbox.html"><strong aria-hidden="true">3.</strong> Dropbox</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rubric</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<p>This framework provides tools for instructors to write student-run grading applications, called &quot;graders&quot;. Graders are written by instructors and distributed to students. When run by the students, the grader will assess their work and send a report to the dropbox, which is maintained by the instructor.</p>
<p>There are 3 significant parts to a grading application</p>
<ol>
<li>A <strong>rubric</strong> - a list of specific criteria that each student must fulfil</li>
<li><strong>Submissions</strong> - An evaluation of a specific student's work and progress through a rubric</li>
<li>A <strong>dropbox</strong> - a collection box for submissions</li>
</ol>
<h2><a class="header" href="#rubrics" id="rubrics">Rubrics</a></h2>
<p>Rubrics are exactly what you would expect; a list of criteria that describe an assignment or test. Each criteria has a point value, and the students grade is determined by the criteria they fulfil.</p>
<h2><a class="header" href="#submissions" id="submissions">Submissions</a></h2>
<p>A submission is a bundle of data that tracks how well the student performed, according to the rubric. Rubrics and submissions are useless without each other. Submissions are meant to be <em>submitted</em> (who knew?) to the instructor. </p>
<h2><a class="header" href="#the-dropbox" id="the-dropbox">The Dropbox</a></h2>
<p>The dropbox is simply a web server maintained by the instructor that recieves submissions and records them. The submissions are recorded as CSV, which is supported by Microsoft Excel. Sorting and manipulation can be performed in Excel after all the submissions are in.</p>
<h1><a class="header" href="#rust-setup" id="rust-setup">Rust Setup</a></h1>
<p>You'll need the Rust language installed, and it's build tool &quot;cargo&quot;. You can <a href="https://www.rust-lang.org/tools/install">read more about that here</a>. It's pretty easy to install on any platform.</p>
<p>You'll also want to switch over to the <code>nightly</code> channel. This crate uses experimental features only available in night. Do that with</p>
<pre><code>$ rustup default nightly
</code></pre>
<h2><a class="header" href="#grader-setup" id="grader-setup">Grader Setup</a></h2>
<p>Once you have Rust installed, you'll want to make a new project to serve as your grading application.</p>
<p>You can create a new Rust project with</p>
<pre><code>cargo new --bin my_grader
</code></pre>
<p>This is a Rust crate and can be installed like any other Rust crate. In the <code>Cargo.toml</code> file that cargo creates for you, add this crate as a dependency.</p>
<pre><code class="language-toml"># ...
[dependencies]
rubric = &quot;0.14&quot; # or latest version
</code></pre>
<p>Now is a good time to create a <code>rubrics/</code> directory alongside your <code>src/</code> directory. You'll use that later.</p>
<p>In your <code>main.rs</code>, delcare the rubric crate and import the items you need.</p>
<pre><code class="language-rust noplaypen">#[macro_use] extern crate rubric;

// import what you need
use rubric::{Rubric, Submission, dropbox};

fn main() {
    // ...
}
</code></pre>
<p>It's also recommended that you create a <code>tests.rs</code> beside <code>main.rs</code> to hold your <a href="./rubric/tests.html">criteria tests</a>.</p>
<p>You may need to access certain items or functions in the <code>rubric</code> crate. You can reference the <a href="https://docs.rs/rubric">docs on docs.rs</a> for specific information.</p>
<h1><a class="header" href="#rubrics-1" id="rubrics-1">Rubrics</a></h1>
<p>Rubrics are the main component of this framework. A rubric is simply a list of criteria. They are the first thing you should write down when writing a grader.</p>
<p>Within this framework, rubrics are represented with <code>.yml</code> files in the <code>rubrics/</code> directory. &quot;YAML&quot; is a markup language that you can <a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html">read about here</a>. It's pretty common within sysadmin tools and chances are you're already familiar with it. We can use YAML to write out the details of our criteria.</p>
<h2><a class="header" href="#a-practical-example" id="a-practical-example">A Practical Example</a></h2>
<p>Rubrics are very easy to understand if you see one.</p>
<p>In the <a href="https://github.com/llamicron/rubric/tree/master/examples/git_lab"><code>git_lab</code> example</a>, we wrote a hypothetical assignment for our hypothetical students. This lab is meant to teach our students about git and how to use it. We came up with 4 criteria that will make up our assignment. These criteria are</p>
<ol>
<li>The student must install git and have it available at the command line</li>
<li>The student must initialize git in a directory</li>
<li>The student must make at least 3 commits in that repository</li>
<li>The student must push the repository to Github and have it publicly accessible</li>
</ol>
<p>This is a great start. All we need to do is formalize this into a rubric.</p>
<pre><code class="language-yml"># Our assignments name
name: Git Lab
# An optional description
desc: A lab to teach git

# Set a deadline
deadline: 2023-06-07 23:59:59
# Don't allow late submissions
allow_late: false


# A list of our criteria
criteria:
  &quot;Git installed&quot;:
    func: git_installed
    desc: Git should be installed and accessible
    worth: 25
    messages: [&quot;installed&quot;, &quot;not installed&quot;]

  &quot;Git initialized in repo&quot;:
    func: git_init
    desc: Current directory should have git initialized
    worth: 25
    messages: [&quot;initialized&quot;, &quot;not initialized&quot;]

  &quot;Commits present&quot;:
    func: commits_present
    worth: 25
    desc: Current git repository should have more than 2 commits

  &quot;Repo pushed&quot;:
    func: repo_pushed
    worth: 25
    desc: Current git repository should be pushed to github
</code></pre>
<p>You can see that each criteria has a name, a point value, and some other configuration options. The only required fields are the name and worth, everything else has defaults.</p>
<p>Lets dissect one of the criteria</p>
<pre><code class="language-yml"># ...
criteria:
  # The criteria name
  &quot;Git installed&quot;:
    # This is the name of the corresponding function.
    # if you omit this, the function name will be the criterion's name,
    # lower-cased and whitespace replaced with dashes
    func: git_installed
    # Just a description. Students will see this when grading
    desc: Git should be installed and accessible
    # The point value, can be any number, even negative.
    worth: 25
    # Success/failure messages. These default to &quot;passed&quot; and &quot;failed&quot;.
    # The're just some extra information for the student
    messages: [&quot;installed&quot;, &quot;not installed&quot;]
</code></pre>
<p>There are a few more options that you can provide, which you can read about on the <a href="rubric/spec.html">Rubric Specification Page</a>.</p>
<h2><a class="header" href="#loading-a-rubric" id="loading-a-rubric">Loading a Rubric</a></h2>
<p>After writing out a rubric in a <code>.yml</code> file, we can load it into our grader and use it.</p>
<p>The first step to loading a rubric is reading the file. This is done with the <code>yaml!</code> macro.</p>
<pre><code class="language-rust noplaypen">let rubric_yaml = yaml!(&quot;../rubrics/main.yml&quot;).expect(&quot;Couldn't load file!&quot;);
</code></pre>
<p><code>yaml!</code> loads a file relative to the current file. It returns a <code>Result</code>, so we can deal with the error if we want. It's usually a good idea to call <code>expect()</code> so the program crashes if the file couldn't be read.</p>
<p><code>yaml!</code> is special because it embeds the <code>.yml</code> in the compiled executable. This means you don't have to distribute the rubric file with the executable. Your rubric can also be kept private if you want it to be.</p>
<p>Next, we just have to pass the YAML data to the <code>Rubric</code> struct like this</p>
<pre><code class="language-rust noplaypen">let rubric = Rubric::from_yaml(&amp;rubric_yaml).expect(&quot;Bad YAML!&quot;);
</code></pre>
<blockquote>
<p>Note: We're using <code>expect()</code> again here. We want the program to crash at <em>compile-time</em> when we're working on the grader, not at <em>run-time</em> when the students are using it. Better for us to deal with the error than them.</p>
</blockquote>
<h2><a class="header" href="#writing-the-tests" id="writing-the-tests">Writing The Tests</a></h2>
<p>We have a rubric loaded, but it has no way to actually verify that the criteria have been fulfilled. We're going to write one function for each of the criteria. The function (called a &quot;criteria test&quot; or just &quot;test&quot;) has the responsibility of ensuring the criteria was actually fulfilled by the student.</p>
<p>Assignments obviously vary greatly in scope and material, so writing these tests is the bulk of the work to be done when writing a grader. It all depends on what the student should be doing.</p>
<p>Things like installing Git or running a web server are easy to verify, but other tasks might not be. Because every criteria has a function, the full force of Rust is on your side. You may have to get creative in writing your tests. You can always look at the <a href="https://github.com/llamicron/rubric/tree/master/examples">examples on Github</a> for inspiration.</p>
<p>See the <a href="rubric/tests.html">Criteria Tests</a> page for more information on this topic.</p>
<h1><a class="header" href="#rubric-specification" id="rubric-specification">Rubric Specification</a></h1>
<p>If you're looking for the syntax of the YAML language itself, then <a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html">look here</a>. This page is for the allowed items in a rubric's <code>.yml</code> file.</p>
<h2><a class="header" href="#minimal-rubric" id="minimal-rubric">Minimal Rubric</a></h2>
<p>Here is a rubric with as few items as possible. Everything here is required.</p>
<pre><code class="language-yml">name: My rubric

criteria:
  &quot;first and only criterion&quot;:
    worth: 10
</code></pre>
<h2><a class="header" href="#all-items" id="all-items">All Items</a></h2>
<p>Here is a full rubric with everything specified, with comments for more information about each key.</p>
<pre><code class="language-yml"># -- Rubric Details --
# Required name
name: My rubric
# Optional description. Gets shown to the student when grading
desc: Description of my rubric
# Sanity check. If the sum of all criteria doesn't add to this number,
# an error message will be displayed. Just ensures that you give the correct
# worth to all criteria
total: 100





# -- Deadline verification --
# All of these are optional
#
# The optional submission deadline. Must be in this format
#   YYYY-MM-DD HH:MM:SS
# It will use the current local timezone.
# If a submission is created after this time, the late flag will be true.
# If you enter a deadline from the past, you will be warned during compilation, but
# compilation will continue.
deadline: 2020-05-21 23:59:59
# If this is set to false, the submission will always have a 
# grade of 0 unless manually changed. Defaults to true (allowing late submission).
# A submission *can* still be submitted if this is false, but its grade will be 0
# and the late flag will be true
allow_late: true
# This amount will be subtracted from the grade if the submission is late
late_penalty: 10





# -- Criteria --
criteria:
  &quot;First criterion&quot;:
    # The name of the corresponding function. This should be unique.
    # If not specified, the function name will be the criterion's name,
    # lowercased and whitespace replaced with dashes. But it's best to be
    # explicit about this.
    # Should match the function name exactly.
    # Because this is unique, it is used to find criteria within a rubric.
    func: whatever_func
    # Any number (even negative). Lowest number is run first.
    # Criteria without indices do not have consistent order
    index: 1
    # A description
    desc: You should do this to fulfil this criterion
    # required point value
    # can be negative
    worth: 50
    # success and failure messages
    # default to &quot;passed&quot; and &quot;failed&quot;
    messages: [&quot;Passed!&quot;, &quot;not passed&quot;]
    # This will prevent the criterion from being displayed
    # to the student. Useful if you want hidden requirements 
    # or are grading a test
    # true or false
    hide: false

  # This criterion has all default values
  &quot;Second criterion&quot;:
    func: second_criterion
    index: 100
    desc: &quot;&quot;
    worth: 0
    messages: [&quot;passed&quot;, &quot;failed&quot;]
    hide: false
</code></pre>
<h1><a class="header" href="#criteria-tests" id="criteria-tests">Criteria Tests</a></h1>
<p>As stated on the <a href="rubric/home.html">Rubrics</a> page, a criteria tests is a Rust function that verifies if a criteria was actually fulfilled. They will vary widely. This page will show how to write a test and a few examples to get you started.</p>
<h2><a class="header" href="#a-single-test" id="a-single-test">A Single Test</a></h2>
<p>Tests are just functions, but they must have a specific signature. They must always accept the same parameters and return the same type of value. Here's the signature</p>
<pre><code class="language-rust noplaypen">// Be sure TestData is imported
use rubric::TestData;

fn my_test(data: &amp;TestData) -&gt; bool {
    // Test code goes here...
}
</code></pre>
<p>Every test must accept a reference to a <code>TestData</code> struct. This <code>TestData</code> is stored on a <a href="rubric/../submission/home.html"><code>Submission</code></a>, which I'll cover in a different section. What you should know now is that it's <em>an alias to</em> <code>HashMap&lt;String, String&gt;</code>.</p>
<p>Sometimes you won't need <code>TestData</code> in a test, in which case you can just name the parameter <code>_</code> and Rust won't complain.</p>
<p>Tests must also return a boolean. <code>true</code> if it passes, <code>false</code> otherwise. If a test returns <code>true</code>, then the associated criteria's worth will be added to the point total. If all the criteria tests return true, the maximum score is achieved.</p>
<h3><a class="header" href="#using-testdata" id="using-testdata">Using <code>TestData</code></a></h3>
<p>Remember that a <code>TestData</code> struct is really just a <code>HashMap</code>. It will contains keys and values that <em>you specify</em> when setting up a <a href="rubric/../submission/home.html"><code>Submission</code></a>. You can use any of the <a href="https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html">methods that HashMap's have</a>. 90% of the time, you'll just want to read a value from the <code>TestData</code>. There's 2 ways to do that.</p>
<pre><code class="language-rust noplaypen">
fn some_test(data: &amp;TestData) -&gt; bool {
    // The easy but dangerous way to get a value
    // this will *crash* if the key doesn't exist
    let my_value = data[&quot;my_key&quot;];

    // The safe way to get a value
    if let Some(value) = data.get(&quot;my_key&quot;) {
        // Key exists, now we have the value
        println!(&quot;Value is {}&quot;, value);
    } else {
        // Key doesn't exist, something went wrong, handle error
        println!(&quot;Value doesn't exist!&quot;);
    }

    // ...
}
</code></pre>
<p>It's important that you take precautions when writing a grader. You really don't want it to crash while your students are running it. The two examples above to the same thing, but the second method won't crash if the key doesn't exist.</p>
<h2><a class="header" href="#organization" id="organization">Organization</a></h2>
<p>I strongly recommend making a <code>test.rs</code> file alongside <code>main.rs</code> to keep your tests in. Of course, you don't have to. You could keep your tests as loose functions in <code>main.rs</code>, or maybe have a submodule in <code>main.rs</code>.</p>
<p>Again, I recommend making a <code>tests.rs</code> file and keeping them in there. Here's how I set things up.</p>
<pre><code class="language-rust noplaypen">// tests.rs
use rubric::TestData;

fn test_from_tests_rs(_: &amp;TestData) -&gt; bool {
    // test code goes here
    return true;
}

// more tests here...
</code></pre>
<pre><code class="language-rust noplaypen">// main.rs
extern crate rubric;

// declare tests.rs as a module
mod tests;
// bring all test functions into scope
use tests::*;
// ...
</code></pre>
<h2><a class="header" href="#attaching-tests" id="attaching-tests">Attaching Tests</a></h2>
<p>Each criteria has an associated test, but we need to tell our program which test goes with which criteria. In our rubric, each criteria should have a <code>func</code> key. This should exactly match the name of the test. Rust uses <code>snake_case</code> for function names. After we've written our tests and loaded our rubric, we can use the <code>attach!</code> macro to assign them.</p>
<pre><code class="language-yaml">name: Basic rubric

criteria:
  &quot;Only criteria&quot;:
    worth: 50
    # This is the important bit
    # it allows attach!() to find the right function
    func: my_criteria_test
    # ...
</code></pre>
<pre><code class="language-rust noplaypen">
fn my_criteria_test(_: &amp;TestData) -&gt; bool {
    // test code goes here...
    return true;
}


fn main() {
    // load rubric
    // code omitted
    // be sure it's mutable
    let mut rubric = //...

    attach!(rubric, my_criteria_test);
}
</code></pre>
<h2><a class="header" href="#helpers" id="helpers">Helpers</a></h2>
<p>There are a few helper modules and functions that perform some common tasks. Sometimes your tests will be one-liners from the helper modules. See the <a href="https://docs.rs/rubric/0.11.1/rubric/helpers/index.html"><code>helpers</code></a> module documentation on docs.rs for more info.</p>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<p>Some basic examples can be found in the <a href="https://github.com/llamicron/rubric/tree/master/examples"><code>examples</code> directory on Github</a>, specifically in <a href="https://github.com/llamicron/rubric/blob/master/examples/git_lab/src/tests.rs">this file</a> in the <code>git_lab</code> example.</p>
<h1><a class="header" href="#submission" id="submission">Submission</a></h1>
<p>A submission represents one students work on an assignment. It contains any data you may want about the student, like name and ID, their grade, which criteria they passed and failed, information about their system, information they provide, etc.</p>
<p>A submission is the other half to a rubric. While rubrics are identical among all students, every student has their own unique submission. The stucture of a submission is all the same, but the values contained in it are unique to each student.</p>
<p>A submission is designed to be constructed during the grading process and sent back to you, the instructor. You'll end up with a list of submissions from every student containing their grade and all the data you specified.</p>
<p>Let's take a gander at a blank <code>Submission</code> struct to see what's in it:</p>
<pre><code class="language-rust noplaypen">Submission {
    time: 2020-08-04 Tue 21:13:34 -05:00,
    grade: 0,
    data: {},
    passed: [],
    failed: [],
}
</code></pre>
<p>There's a few default values like a timestamp, grade, and which criteria the submission passed and failed, but it's pretty empty. The important bit is the <code>data</code> <code>HashMap</code>. This is where all of the data you specify will live. All of this data will be collected when the student runs the grader, and will be sent back as part of the grade report.</p>
<h2><a class="header" href="#the-data-macro" id="the-data-macro">The <code>data!</code> macro</a></h2>
<p>I mentioned that the <code>data</code> field on a submission is a <code>HashMap</code>. This is sort of true. It's technically a <code>TestData</code>, which is an alias to <code>HashMap&lt;String, String&gt;</code>.</p>
<p>If you read the <a href="submission/../rubric/tests.html">Criteria Tests</a> section, you might remember <code>TestData</code> as the value that criteria tests must accept as a parameter. The <code>TestData</code> on a submission is what will be passed into these tests.</p>
<p>Rust does not have object literals the same way a language like Python does. Instead, this crate provides a <code>data!</code> macro that will create a <code>TestData</code> for you. Here's how to use it.</p>
<pre><code class="language-rust noplaypen">let data = data! {
    &quot;some_key&quot; =&gt; &quot;some value&quot;,
    &quot;other_key&quot; =&gt; &quot;other value&quot;
};
</code></pre>
<p>Since <code>TestData</code> is an alias to <code>HashMap&lt;String, String&gt;</code>, the keys and values must be strings.</p>
<h2><a class="header" href="#creating-a-submission" id="creating-a-submission">Creating a Submission</a></h2>
<p>Creating a submission is easy</p>
<pre><code class="language-rust noplaypen">// creates a blank submission like the one above
let sub = Submission::new();
</code></pre>
<p>You will most likely want to create a submission with some data. You can do that like this.</p>
<pre><code class="language-rust noplaypen">let data = data! {
    &quot;key&quot; =&gt; &quot;value&quot;
};

let sub = Submission::from_data(data);

// This will create the following
Submission {
    time: 2020-08-04 Tue 21:13:34 -05:00,
    grade: 0,
    data: {
        &quot;key&quot;: &quot;value&quot;,
    },
    passed: [],
    failed: [],
}
</code></pre>
<h1><a class="header" href="#prompting-for-data" id="prompting-for-data">Prompting for Data</a></h1>
<p>When creating a submission, you'll almost always want to ask the student for some information. Usually their name and ID, but maybe some other information as well.</p>
<p>The <code>prompt!</code> macro does this easily. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Asks for something, enforces the correct type
    let name = prompt!(&quot;Name: &quot;, String);
    // Will loop until they enter a number
    let age = prompt!(&quot;Age: &quot;, usize);
    // Will loop until they enter a valid IPv4 address
    let ip = prompt!(&quot;IP Addr: &quot;, std::net::Ipv4Addr);
}
</code></pre></pre>
<p>You can combine this with the <code>data!</code> macro to easily collect information from the user and encapsulate it in a submission.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let data = data! {
        &quot;name&quot; =&gt; prompt!(&quot;Name: &quot;, String),
        &quot;id&quot;   =&gt; prompt!(&quot;ID: &quot;, String)
    }
}
</code></pre>
<blockquote>
<p>Note: because <code>TestData</code> must contain string values, you lose out on the type enforcement that <code>prompt!</code> provides. This is an unfortunate side effect of the <code>TestData</code> type; all values must be strings.</p>
</blockquote>
<h1><a class="header" href="#dropbox" id="dropbox">Dropbox</a></h1>
<p>A dropbox is a place to send submissions after they're done being graded. It recieves submissions in JSON format and writes them to a CSV file for review by the instructor.</p>
<p>The dropbox is a web server run by you, the instructor. It should be run on a publicly available server with a static IP or DNS name. The web server comes preconfigured, all you need to do is give it an environment to run it.</p>
<p>You can open the dropbox by calling the <code>dropbox::open(PORT)</code> method, where <code>PORT</code> is a valid port number.</p>
<pre><pre class="playground"><code class="language-rust">extern crate rubric;
use rubric::dropbox;

fn main() {
    // Runs the dropbox on port 8080
    dropbox::open(8080);

    // or...
    // Only opens when you run with the &quot;open_sesame&quot; argument,
    // otherwise does nothing
    dropbox::open_with_arg(&quot;open_sesame&quot;, 8080);
}
</code></pre></pre>
<p>You'll see the following output</p>
<pre><code>Dropbox is open! accepting POST requests to /submit
ï¿½ðŸ”§ Configured for development.
    =&gt; address: 0.0.0.0
    =&gt; port: 8080
    =&gt; log: normal
    =&gt; workers: 24
    =&gt; secret key: generated
    =&gt; limits: forms = 32KiB
    =&gt; keep-alive: 5s
    =&gt; tls: disabled
ðŸ›°  Mounting /:
    =&gt; GET / (return_ok)
    =&gt; POST /submit application/json (accept_submission)
ï¿½ï¿½ï¿½ Rocket has launched from http://0.0.0.0:8080       
</code></pre>
<p>The home route (<code>/</code>) should return an OK status, but no content. If you visit the url of your webserver, you should get a blank web page. This is good, it means everything is working properly.</p>
<h2><a class="header" href="#submitting-to-the-dropbox" id="submitting-to-the-dropbox">Submitting to the dropbox</a></h2>
<p>Submissions come with a <code>submit()</code> method meant to work with the dropbox. </p>
<pre><pre class="playground"><code class="language-rust">extern crate rubric;
use rubric::Submission;

fn main() {
    let submission = Submission::new();
    
    // grade...

    // assuming your dropbox is running at this url
    let url = &quot;http://my.dns.name.or.ip.com:8080/submit&quot;;

    // Submit and give some feedback
    match submission.submit(&amp;url) {
        Ok(_)  =&gt; println!(&quot;Submission recorded!&quot;),
        Err(e) =&gt; println!(&quot;Something went wrong! {}&quot;, e),
    };
}
</code></pre></pre>
<p>The <code>post_json()</code> method in the <code>helpers::web</code> module is made with the dropbox in mind. After creating and grading a Submission, just pass it and the url of your dropbox to send the submission.</p>
<pre><pre class="playground"><code class="language-rust">extern crate rubric;
use rubric::{Submission, dropbox, helpers::web};

fn main() {
    let submission = Submission::new();
    
    // grade...

    // assuming your dropbox is running at this url
    let url = &quot;http://my.dns.name.or.ip.com:8080/submit&quot;;

    // Submit and give some feedback
    match web::post_json(&amp;url, &amp;sub) {
        Ok(_)  =&gt; println!(&quot;Submission recorded!&quot;),
        Err(e) =&gt; println!(&quot;Something went wrong! {}&quot;, e),
    };
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
